<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libbgp: route-event-bus.cc</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libbgp
   &#160;<span id="projectnumber">0.2</span>
   </div>
   <div id="projectbrief">A C++ BGP Library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">route-event-bus.cc</div>  </div>
</div><!--header-->
<div class="contents">
<p>Example of adding new routes to RIB while BGP FSM is running. Notify BGP FSM to send updates to the peer with RouteEventBus. This example also shows how you can implement your own BgpOutHandler and BgpLogHandler.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;libbgp/bgp-fsm.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;libbgp/route-event-bus.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;arpa/inet.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sys/types.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// In this example, we don&#39;t connect to any remote peer. Instead, we have </span></div><div class="line"><span class="comment">// another BGP FSM running as a &quot;remote&quot; BGP speaker. </span></div><div class="line"></div><div class="line"><span class="comment">// We can create our own RouteEventReceiver to get notified when route changes.</span></div><div class="line"><span class="comment">// The routing information is available with BgpRib object, but you won&#39;t know </span></div><div class="line"><span class="comment">// if there have been new routes added to the RIB.</span></div><div class="line"><span class="comment">// RouteEventReceiver is an interface for RouteEventBus participant. </span></div><div class="line"><span class="comment">// RouteEventBus is usually used by BGP FSMs to communicate with each other. </span></div><div class="line"><span class="comment">// (since every FSM handle a single BGP session, and there might be multiple BGP</span></div><div class="line"><span class="comment">// sessions running at a time) RouteEventBus allow BGP FSMs to pass route </span></div><div class="line"><span class="comment">// add/withdrawn updates to other FSMs. (collision detection is also done </span></div><div class="line"><span class="comment">// through RouteEventBus)</span></div><div class="line"><span class="keyword">class </span>MyEventHandler : <span class="keyword">public</span> <a name="_a0"></a><a class="code" href="classlibbgp_1_1RouteEventReceiver.html">libbgp::RouteEventReceiver</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MyEventHandler(<span class="keyword">const</span> <span class="keywordtype">char</span> *name) {</div><div class="line">        this-&gt;name = name;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keywordtype">bool</span> <a name="a1"></a><a class="code" href="classlibbgp_1_1RouteEventReceiver.html#acb49d33f47dcc9a15d89b50aad6cf652">handleRouteEvent</a>(<span class="keyword">const</span> <a name="_a2"></a><a class="code" href="classlibbgp_1_1RouteEvent.html">libbgp::RouteEvent</a> &amp;ev) {</div><div class="line">        <span class="keywordflow">if</span> (ev.<a name="a3"></a><a class="code" href="classlibbgp_1_1RouteEvent.html#a7ebada61b6b2b9b8e6128099abbc671d">type</a> == libbgp::ADD) {</div><div class="line">            <span class="keyword">const</span> <a name="_a4"></a><a class="code" href="classlibbgp_1_1RouteAddEvent.html">libbgp::RouteAddEvent</a> &amp;add_ev = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="classlibbgp_1_1RouteAddEvent.html">libbgp::RouteAddEvent</a> &amp;<span class="keyword">&gt;</span>(ev);</div><div class="line">            printRoutes(<span class="stringliteral">&quot;add&quot;</span>, add_ev.<a name="a5"></a><a class="code" href="classlibbgp_1_1RouteAddEvent.html#a0d94b0e261921f2a8b494babc4e76193">routes</a>);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (ev.<a class="code" href="classlibbgp_1_1RouteEvent.html#a7ebada61b6b2b9b8e6128099abbc671d">type</a> == libbgp::WITHDRAW) {</div><div class="line">            <span class="keyword">const</span> <a name="_a6"></a><a class="code" href="classlibbgp_1_1RouteWithdrawEvent.html">libbgp::RouteWithdrawEvent</a> &amp;wd_ev = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="classlibbgp_1_1RouteWithdrawEvent.html">libbgp::RouteWithdrawEvent</a> &amp;<span class="keyword">&gt;</span>(ev);</div><div class="line">            printRoutes(<span class="stringliteral">&quot;withdraw&quot;</span>, wd_ev.<a name="a7"></a><a class="code" href="classlibbgp_1_1RouteWithdrawEvent.html#ae9245ff18d4030bf2cdd6ac5987fd019">routes</a>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// we are just peeking the events, no need to report event handled</span></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> printRoutes(<span class="keyword">const</span> <span class="keywordtype">char</span> *type, <span class="keyword">const</span> std::vector&lt;libbgp::Route&gt; &amp;routes) {</div><div class="line">        <span class="keywordtype">char</span> ip_str[INET_ADDRSTRLEN];</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <a name="_a8"></a><a class="code" href="classlibbgp_1_1Route.html">libbgp::Route</a> &amp;r : routes) {</div><div class="line">            uint32_t prefix = r.getPrefix();</div><div class="line">            inet_ntop(AF_INET, &amp;prefix, ip_str, INET_ADDRSTRLEN);</div><div class="line">            printf(<span class="stringliteral">&quot;[%s] %s: %s/%d\n&quot;</span>, name, type, ip_str, r.getLength());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *name;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Implement our output handler to pass data directly to another BGP FSM. </span></div><div class="line"><span class="comment">// BgpOutHandler is used by BGP FSM to write BGP message to peer. </span></div><div class="line"><span class="comment">// Usually, BGP FSM will write messages to a peer with a TCP socket. (a file </span></div><div class="line"><span class="comment">// descriptor). In that case, we use FdOutHandler, which comes with libbgp. </span></div><div class="line"><span class="comment">// However, here we want to talk to another BGP FSM running in the same program.</span></div><div class="line"><span class="keyword">class </span>PipedOutHandler : <span class="keyword">public</span> <a name="_a9"></a><a class="code" href="classlibbgp_1_1BgpOutHandler.html">libbgp::BgpOutHandler</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    PipedOutHandler() {</div><div class="line">        other = NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setPeer(<a name="_a10"></a><a class="code" href="classlibbgp_1_1BgpFsm.html">libbgp::BgpFsm</a> *other) {</div><div class="line">        this-&gt;other = other;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> handleOut(<span class="keyword">const</span> uint8_t *buffer, <span class="keywordtype">size_t</span> length) {</div><div class="line">        <span class="keywordflow">return</span> other-&gt;<a name="a11"></a><a class="code" href="classlibbgp_1_1BgpFsm.html#adea892746fa368c182575d949e4565d3">run</a>(buffer, length) &gt;= 0;</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <a class="code" href="classlibbgp_1_1BgpFsm.html">libbgp::BgpFsm</a> *other;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Since we have two FSMs here, we want to label their log output so we know</span></div><div class="line"><span class="comment">// where the log is comming from. Implement our own log handler so we can label</span></div><div class="line"><span class="comment">// the log output.</span></div><div class="line"><span class="keyword">class </span>MyLoghandler : <span class="keyword">public</span> <a name="_a12"></a><a class="code" href="classlibbgp_1_1BgpLogHandler.html">libbgp::BgpLogHandler</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MyLoghandler(<span class="keyword">const</span> <span class="keywordtype">char</span> *name) {</div><div class="line">        this-&gt;name = name;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keywordtype">void</span> logImpl(<span class="keyword">const</span> <span class="keywordtype">char</span>* str) {</div><div class="line">        printf(<span class="stringliteral">&quot;[%s] %s&quot;</span>, name, str);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *name;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">/* create the &quot;local&quot; BGP speaker */</span></div><div class="line">    <a name="_a13"></a><a class="code" href="structlibbgp_1_1BgpConfig.html">libbgp::BgpConfig</a> local_bgp_config;</div><div class="line">    PipedOutHandler pipe_local; <span class="comment">// create the output pipe</span></div><div class="line">    MyLoghandler local_logger(<span class="stringliteral">&quot;local&quot;</span>); <span class="comment">// create the logger for local speaker</span></div><div class="line">    local_logger.setLogLevel(libbgp::DEBUG);</div><div class="line"></div><div class="line">    <span class="comment">/* create the route event bus for our home-made receiver to print routes */</span></div><div class="line">    <a name="_a14"></a><a class="code" href="classlibbgp_1_1RouteEventBus.html">libbgp::RouteEventBus</a> local_bus; <span class="comment">// create the event bus</span></div><div class="line">    MyEventHandler local_handler(<span class="stringliteral">&quot;local&quot;</span>); <span class="comment">// create our event subscriber</span></div><div class="line">    local_bus.<a name="a15"></a><a class="code" href="classlibbgp_1_1RouteEventBus.html#a8479fcd6ead5e448841eb46610ab00d2">subscribe</a>(&amp;local_handler); <span class="comment">// subscribe to it</span></div><div class="line"></div><div class="line">    <span class="comment">// create the rib. the logger is optional. setting a logger enable verbose</span></div><div class="line">    <span class="comment">// output on rib.</span></div><div class="line">    <a name="_a16"></a><a class="code" href="classlibbgp_1_1BgpRib.html">libbgp::BgpRib</a> local_rib(&amp;local_logger); </div><div class="line"></div><div class="line">    <span class="comment">/* set config parameters for local speaker */</span></div><div class="line">    local_bgp_config.<a name="a17"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#a50058772fbf44f0bf8be1ae3779fa9cd">asn</a> = 65000; <span class="comment">// set local ASN</span></div><div class="line">    local_bgp_config.<a name="a18"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#a0a4d1662bac518cd66bcce3ed35195c6">peer_asn</a> = 65001; <span class="comment">// set peer ASN</span></div><div class="line">    local_bgp_config.<a name="a19"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#ab225af5f692ee473e457515350297b68">use_4b_asn</a> = <span class="keyword">true</span>; <span class="comment">// enable RFC 6793</span></div><div class="line">    local_bgp_config.<a name="a20"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#a71d932a32d7d9b89c8327f578bad17d5">hold_timer</a> = 120; <span class="comment">// hold timer</span></div><div class="line">    local_bgp_config.<a name="a21"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#a055a838bffab8e0cbdea22abf536c0ca">out_handler</a> = &amp;pipe_local; <span class="comment">// handle output with bridge</span></div><div class="line">    local_bgp_config.<a name="a22"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#ac42b213e8a941eeff8688b049bc05a31">no_collision_detection</a> = <span class="keyword">true</span>; <span class="comment">// no need for that</span></div><div class="line"></div><div class="line">    <span class="comment">// use our pre-defined RIB. We may also set this to NULL, this will make</span></div><div class="line">    <span class="comment">// BgpFsm create RIB itself. We can get the created RIB with BgpFsm::getRib.</span></div><div class="line">    <span class="comment">// Demo of that can be found in route-filter.cc example.</span></div><div class="line">    local_bgp_config.<a name="a23"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#a6ef827d9bd4ab03278adf89e4bebd165">rib</a> = &amp;local_rib; </div><div class="line"></div><div class="line">    <span class="comment">// use our local event bus.</span></div><div class="line">    local_bgp_config.<a name="a24"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#a0f49c37a2db3ba92b358bed0b9ff1d86">rev_bus</a> = &amp;local_bus; </div><div class="line"></div><div class="line">    local_bgp_config.<a name="a25"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#a85433acb7a5ca8620fa4cf79f5d50798">clock</a> = NULL; <span class="comment">// use system clock.</span></div><div class="line">    local_bgp_config.<a name="a26"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#ab3b993e8b2958966c1e2318a08b5655e">log_handler</a> = &amp;local_logger; </div><div class="line"></div><div class="line">    inet_pton(AF_INET, <span class="stringliteral">&quot;10.0.0.1&quot;</span>, &amp;local_bgp_config.<a name="a27"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#acc50e2d37d8b44e2c69d907281253f55">router_id</a>); <span class="comment">// router id</span></div><div class="line"></div><div class="line">    <span class="comment">// nexthop selection and nexthop validation is done with peering_lan_*</span></div><div class="line">    <span class="comment">// configutaion. For simplicity, we are disabling those checks here. Router</span></div><div class="line">    <span class="comment">// server example has demonstrated how peer_lan_* were used. For detailed </span></div><div class="line">    <span class="comment">// usage, refer to the document.</span></div><div class="line"></div><div class="line">    <span class="comment">// always use 10.0.0.1 as nexthop. </span></div><div class="line">    inet_pton(AF_INET, <span class="stringliteral">&quot;10.0.0.1&quot;</span>, &amp;local_bgp_config.<a name="a28"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#a815897482ba557776bef52b47b4ea988">nexthop</a>); </div><div class="line">    local_bgp_config.<a name="a29"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#a7809bedbb1037aff0d1b162ca66c11f5">forced_default_nexthop</a> = <span class="keyword">true</span>; </div><div class="line"></div><div class="line">    <span class="comment">// don&#39;t validate nexthop of routes received from peer.</span></div><div class="line">    local_bgp_config.<a name="a30"></a><a class="code" href="structlibbgp_1_1BgpConfig.html#a2e3e9617d3e7bdc4d90c7899eb456864">no_nexthop_check</a> = <span class="keyword">true</span>; </div><div class="line"></div><div class="line">    <span class="comment">// pre-fill the RIB with a route.</span></div><div class="line">    <a class="code" href="classlibbgp_1_1Route.html">libbgp::Route</a> r_141_193_21_24 (<span class="stringliteral">&quot;141.193.21.0&quot;</span>, 24);</div><div class="line">    local_rib.<a name="a31"></a><a class="code" href="classlibbgp_1_1BgpRib.html#a051c31d60149506a07495cbe9a10a6a8">insert</a>(&amp;local_logger, r_141_193_21_24, local_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a815897482ba557776bef52b47b4ea988">nexthop</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* create the &quot;remote&quot; BGP speaker */</span></div><div class="line">    <a class="code" href="structlibbgp_1_1BgpConfig.html">libbgp::BgpConfig</a> remote_bgp_config;</div><div class="line">    PipedOutHandler pipe_remote; <span class="comment">// create the output pipe</span></div><div class="line">    MyLoghandler remote_logger(<span class="stringliteral">&quot;remote&quot;</span>); <span class="comment">// create the logger for remote speaker</span></div><div class="line">    remote_logger.setLogLevel(libbgp::DEBUG);</div><div class="line"></div><div class="line">    <span class="comment">/* create the route event bus for our home-made receiver to print routes */</span></div><div class="line">    <a class="code" href="classlibbgp_1_1RouteEventBus.html">libbgp::RouteEventBus</a> remote_bus; <span class="comment">// create the event bus</span></div><div class="line">    MyEventHandler remote_handler(<span class="stringliteral">&quot;remote&quot;</span>); <span class="comment">// create our event subscriber</span></div><div class="line">    remote_bus.<a class="code" href="classlibbgp_1_1RouteEventBus.html#a8479fcd6ead5e448841eb46610ab00d2">subscribe</a>(&amp;remote_handler); <span class="comment">// subscribe to it</span></div><div class="line"></div><div class="line">    <span class="comment">/* set config parameters for remote speaker */</span></div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a50058772fbf44f0bf8be1ae3779fa9cd">asn</a> = 65001; <span class="comment">// set local ASN</span></div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a0a4d1662bac518cd66bcce3ed35195c6">peer_asn</a> = 65000; <span class="comment">// set peer ASN</span></div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#ab225af5f692ee473e457515350297b68">use_4b_asn</a> = <span class="keyword">true</span>; <span class="comment">// enable RFC 6793</span></div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a71d932a32d7d9b89c8327f578bad17d5">hold_timer</a> = 120; <span class="comment">// hold timer</span></div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a055a838bffab8e0cbdea22abf536c0ca">out_handler</a> = &amp;pipe_remote; <span class="comment">// handle output with bridge</span></div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#ac42b213e8a941eeff8688b049bc05a31">no_collision_detection</a> = <span class="keyword">true</span>; <span class="comment">// no need for that</span></div><div class="line"></div><div class="line">    <span class="comment">// remote: not using a pre-defined RIB.</span></div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a6ef827d9bd4ab03278adf89e4bebd165">rib</a> = NULL; </div><div class="line"></div><div class="line">    <span class="comment">// use our remote event bus.</span></div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a0f49c37a2db3ba92b358bed0b9ff1d86">rev_bus</a> = &amp;remote_bus; </div><div class="line"></div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a85433acb7a5ca8620fa4cf79f5d50798">clock</a> = NULL; <span class="comment">// use system clock.</span></div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#ab3b993e8b2958966c1e2318a08b5655e">log_handler</a> = &amp;remote_logger; </div><div class="line"></div><div class="line">    inet_pton(AF_INET, <span class="stringliteral">&quot;10.0.0.2&quot;</span>, &amp;remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#acc50e2d37d8b44e2c69d907281253f55">router_id</a>); <span class="comment">// router id</span></div><div class="line"></div><div class="line">    <span class="comment">// nexthop selection and nexthop validation is done with peering_lan_*</span></div><div class="line">    <span class="comment">// configutaion. For simplicity, we are disabling those checks here. Router</span></div><div class="line">    <span class="comment">// server example has demonstrated how peer_lan_* were used. For detailed </span></div><div class="line">    <span class="comment">// usage, refer to the document.</span></div><div class="line"></div><div class="line">    <span class="comment">// always use 10.0.0.2 as nexthop. </span></div><div class="line">    inet_pton(AF_INET, <span class="stringliteral">&quot;10.0.0.2&quot;</span>, &amp;remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a815897482ba557776bef52b47b4ea988">nexthop</a>); </div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a7809bedbb1037aff0d1b162ca66c11f5">forced_default_nexthop</a> = <span class="keyword">true</span>; </div><div class="line"></div><div class="line">    <span class="comment">// don&#39;t validate nexthop of routes received from peer.</span></div><div class="line">    remote_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a2e3e9617d3e7bdc4d90c7899eb456864">no_nexthop_check</a> = <span class="keyword">true</span>; </div><div class="line">    </div><div class="line">    <span class="comment">/* create the FSMs and connect them with each other */</span></div><div class="line">    <a class="code" href="classlibbgp_1_1BgpFsm.html">libbgp::BgpFsm</a> local(local_bgp_config);</div><div class="line">    <a class="code" href="classlibbgp_1_1BgpFsm.html">libbgp::BgpFsm</a> remote(remote_bgp_config);</div><div class="line">    pipe_local.setPeer(&amp;remote);</div><div class="line">    pipe_remote.setPeer(&amp;local);</div><div class="line"></div><div class="line">    <span class="comment">// sent OPEN message from local.</span></div><div class="line">    local.<a name="a32"></a><a class="code" href="classlibbgp_1_1BgpFsm.html#a297b5f43430153e579f9c4b75d214fca">start</a>();</div><div class="line"></div><div class="line">    <span class="comment">// BGP peering has established from this point, let send some routes from</span></div><div class="line">    <span class="comment">// local to remote.</span></div><div class="line"></div><div class="line">    <span class="comment">// a route, 172.30.0.0/24.</span></div><div class="line">    <a class="code" href="classlibbgp_1_1Route.html">libbgp::Route</a> r_172_30_24 (<span class="stringliteral">&quot;172.30.0.0&quot;</span>, 24);</div><div class="line"></div><div class="line">    <span class="comment">// put the route in RIB. </span></div><div class="line">    <span class="keyword">const</span> <a name="_a33"></a><a class="code" href="classlibbgp_1_1BgpRibEntry.html">libbgp::BgpRibEntry</a> *inserted = local_rib.<a class="code" href="classlibbgp_1_1BgpRib.html#a051c31d60149506a07495cbe9a10a6a8">insert</a>(&amp;local_logger, r_172_30_24, local_bgp_config.<a class="code" href="structlibbgp_1_1BgpConfig.html#a815897482ba557776bef52b47b4ea988">nexthop</a>);</div><div class="line"></div><div class="line">    <span class="comment">// BGP FSM will send all routes to peer (filtered with egress route filters </span></div><div class="line">    <span class="comment">// if set) when peering established. However, if the session is already </span></div><div class="line">    <span class="comment">// started, BGP FSM will have no way knowing there&#39;s new routes added to the</span></div><div class="line">    <span class="comment">// RIB. We will need to notify BGP FSM with route event bus. </span></div><div class="line"></div><div class="line">    <span class="comment">// create an route-add event.</span></div><div class="line">    <a class="code" href="classlibbgp_1_1RouteAddEvent.html">libbgp::RouteAddEvent</a> add_event;</div><div class="line">    add_event.<a class="code" href="classlibbgp_1_1RouteAddEvent.html#a0d94b0e261921f2a8b494babc4e76193">routes</a>.push_back(inserted-&gt;<a name="a34"></a><a class="code" href="classlibbgp_1_1BgpRibEntry.html#adf15885aace5c747eabceb95cb5b458a">route</a>);</div><div class="line">    add_event.<a name="a35"></a><a class="code" href="classlibbgp_1_1RouteAddEvent.html#aaff7b8bf5c298d5c538dbfdc235bbbba">attribs</a> = inserted-&gt;<a name="a36"></a><a class="code" href="classlibbgp_1_1BgpRibEntry.html#a4a16bb9f1f335019907ad924b3296087">attribs</a>;</div><div class="line"></div><div class="line">    <span class="comment">// publish the event with event bus. The first parameter is pointer to the</span></div><div class="line">    <span class="comment">// publisher, and it is for ensuring publisher of the event does not</span></div><div class="line">    <span class="comment">// receive the event it published itself. You may use NULL if you are not</span></div><div class="line">    <span class="comment">// subscribed to the event bus.</span></div><div class="line">    <span class="comment">// When a BGP FSM receive an add route event from event bus, it will filter</span></div><div class="line">    <span class="comment">// the routes in event payload with egress route filters, and send routes</span></div><div class="line">    <span class="comment">// to the peer.</span></div><div class="line">    local_bus.<a name="a37"></a><a class="code" href="classlibbgp_1_1RouteEventBus.html#aca68243e992480debcef8011cf0a0886">publish</a>(&amp;local_handler, add_event);</div><div class="line"></div><div class="line">    <span class="comment">// now let drop that route we just added from RIB.</span></div><div class="line">    local_rib.<a name="a38"></a><a class="code" href="classlibbgp_1_1BgpRib.html#a70783157aeccf693ea1bf7300b6a0280">withdraw</a>(0, r_172_30_24);</div><div class="line"></div><div class="line">    <span class="comment">// and notify the FSM.</span></div><div class="line">    <a class="code" href="classlibbgp_1_1RouteWithdrawEvent.html">libbgp::RouteWithdrawEvent</a> withdraw_event;</div><div class="line">    withdraw_event.<a class="code" href="classlibbgp_1_1RouteWithdrawEvent.html#ae9245ff18d4030bf2cdd6ac5987fd019">routes</a>.push_back(r_172_30_24);</div><div class="line">    local_bus.<a class="code" href="classlibbgp_1_1RouteEventBus.html#aca68243e992480debcef8011cf0a0886">publish</a>(&amp;local_handler, withdraw_event);</div><div class="line"></div><div class="line">    <span class="comment">// clean up</span></div><div class="line">    local.<a name="a39"></a><a class="code" href="classlibbgp_1_1BgpFsm.html#a2cfd8eca823780e49d2f3bd61cdb68c2">stop</a>();</div><div class="line">    remote.<a class="code" href="classlibbgp_1_1BgpFsm.html#a2cfd8eca823780e49d2f3bd61cdb68c2">stop</a>();</div><div class="line">    remote_bus.<a name="a40"></a><a class="code" href="classlibbgp_1_1RouteEventBus.html#a55ddb50c9ae7fc4883a5cb9654ceb1c5">unsubscribe</a>(&amp;remote_handler);</div><div class="line">    local_bus.<a class="code" href="classlibbgp_1_1RouteEventBus.html#a55ddb50c9ae7fc4883a5cb9654ceb1c5">unsubscribe</a>(&amp;local_handler);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
